#!/usr/bin/env python3
"""
G-code Generator for Hot-Wire Foam Cutting
Supports 2D contour cutting, pocket cutting, and 3D surface cutting
"""

import math
import json
from typing import List, Tuple, Optional

try:
    import ezdxf
    HAS_EZDXF = True
except ImportError:
    HAS_EZDXF = False


class GCodeGenerator:
    def __init__(self):
        self.units = "mm"  # mm or inches
        self.feed_rate = 100.0  # mm/min
        self.wire_temp = 200.0  # Temperature setting (if your machine supports it)
        self.safety_height = 10.0  # Safe Z height for moves
        self.cut_depth = 0.0  # Current cutting depth
        self.current_x = 0.0
        self.current_y = 0.0
        self.current_z = 0.0
        self.lines = []
        
    def set_units(self, units: str):
        """Set units: 'mm' or 'inches'"""
        self.units = units
        
    def set_feed_rate(self, rate: float):
        """Set feed rate in mm/min"""
        self.feed_rate = rate
        
    def set_wire_temp(self, temp: float):
        """Set wire temperature"""
        self.wire_temp = temp
        
    def set_safety_height(self, height: float):
        """Set safe Z height for rapid moves"""
        self.safety_height = height
        
    def add_line(self, line: str):
        """Add a G-code line"""
        self.lines.append(line)
        
    def header(self, comment: str = "Foam Cutting G-code"):
        """Generate G-code header"""
        self.lines = []
        self.add_line(f"; {comment}")
        self.add_line(f"; Generated by G-code Generator for Foam Cutting")
        self.add_line("")
        
        # Set units
        if self.units == "mm":
            self.add_line("G21 ; Set units to millimeters")
        else:
            self.add_line("G20 ; Set units to inches")
            
        # Initialize
        self.add_line("G90 ; Absolute positioning")
        self.add_line("G17 ; XY plane selection")
        self.add_line("G94 ; Feed rate in units/min")
        self.add_line("")
        
        # Move to safe height
        self.add_line(f"G0 Z{self.safety_height:.3f} ; Move to safe height")
        self.add_line("")
        
    def footer(self):
        """Generate G-code footer"""
        self.add_line("")
        self.add_line("; End of program")
        self.add_line("M5 ; Stop spindle/wire (if applicable)")
        self.add_line(f"G0 Z{self.safety_height:.3f} ; Move to safe height")
        self.add_line("G0 X0 Y0 ; Return to home")
        self.add_line("M30 ; End program")
        
    def rapid_move(self, x: Optional[float] = None, y: Optional[float] = None, 
                   z: Optional[float] = None):
        """Rapid positioning move (G0)"""
        cmd = "G0"
        if x is not None:
            cmd += f" X{x:.3f}"
            self.current_x = x
        if y is not None:
            cmd += f" Y{y:.3f}"
            self.current_y = y
        if z is not None:
            cmd += f" Z{z:.3f}"
            self.current_z = z
        self.add_line(cmd)
        
    def linear_move(self, x: Optional[float] = None, y: Optional[float] = None,
                   z: Optional[float] = None, feed: Optional[float] = None):
        """Linear cutting move (G1)"""
        cmd = "G1"
        if x is not None:
            cmd += f" X{x:.3f}"
            self.current_x = x
        if y is not None:
            cmd += f" Y{y:.3f}"
            self.current_y = y
        if z is not None:
            cmd += f" Z{z:.3f}"
            self.current_z = z
        if feed is not None:
            cmd += f" F{feed:.3f}"
        else:
            cmd += f" F{self.feed_rate:.3f}"
        self.add_line(cmd)
        
    def arc_move(self, x: float, y: float, i: float, j: float, 
                clockwise: bool = False, feed: Optional[float] = None):
        """Arc move (G2/G3)"""
        cmd = "G2" if clockwise else "G3"
        cmd += f" X{x:.3f} Y{y:.3f} I{i:.3f} J{j:.3f}"
        if feed is not None:
            cmd += f" F{feed:.3f}"
        else:
            cmd += f" F{self.feed_rate:.3f}"
        self.add_line(cmd)
        self.current_x = x
        self.current_y = y
        
    def cut_contour(self, points: List[Tuple[float, float]], 
                   closed: bool = True, depth: float = 0.0,
                   start_index: Optional[int] = None,
                   clockwise: Optional[bool] = None):
        """Cut a 2D contour
        
        Args:
            points: List of (x, y) tuples
            closed: Whether the contour is closed
            depth: Cutting depth
            start_index: Index of point to start from (None = use first point)
            clockwise: Direction for closed shapes (None = auto, True = clockwise, False = counter-clockwise)
        """
        if not points:
            return
        
        # Determine start point
        if start_index is not None and 0 <= start_index < len(points):
            start_idx = start_index
        else:
            start_idx = 0
        
        # Reorder points to start from specified index
        if start_idx > 0:
            points = points[start_idx:] + points[:start_idx]
        
        # Reverse direction if needed (for closed shapes)
        if closed and len(points) > 2 and clockwise is not None:
            # Calculate signed area to determine natural direction
            # Positive area = counter-clockwise, negative = clockwise
            area = 0.0
            for i in range(len(points)):
                j = (i + 1) % len(points)
                area += points[i][0] * points[j][1]
                area -= points[j][0] * points[i][1]
            
            is_naturally_clockwise = area < 0
            
            # If requested direction doesn't match natural direction, reverse
            if clockwise != is_naturally_clockwise:
                # Reverse all points except the first
                points = [points[0]] + list(reversed(points[1:]))
        
        # Move to start position
        start_x, start_y = points[0]
        self.rapid_move(x=start_x, y=start_y)
        self.rapid_move(z=depth)
        
        # Cut along contour
        for i, (x, y) in enumerate(points):
            if i == 0:
                continue
            self.linear_move(x=x, y=y, z=depth)
            
        # Close the contour if needed
        if closed and len(points) > 2:
            self.linear_move(x=start_x, y=start_y, z=depth)
            
        # Retract
        self.rapid_move(z=self.safety_height)
        self.add_line("")
        
    def cut_circle(self, center_x: float, center_y: float, radius: float,
                  depth: float = 0.0, start_angle: float = 0.0, 
                  end_angle: float = 360.0):
        """Cut a circle using arc moves"""
        if end_angle - start_angle >= 360.0:
            # Full circle - use multiple arcs
            num_segments = 4
            angle_step = 360.0 / num_segments
            points = []
            
            for i in range(num_segments + 1):
                angle = math.radians(start_angle + i * angle_step)
                x = center_x + radius * math.cos(angle)
                y = center_y + radius * math.sin(angle)
                points.append((x, y))
                
            self.cut_contour(points, closed=False, depth=depth)
        else:
            # Partial circle - use arc
            start_rad = math.radians(start_angle)
            end_rad = math.radians(end_angle)
            
            start_x = center_x + radius * math.cos(start_rad)
            start_y = center_y + radius * math.sin(start_rad)
            end_x = center_x + radius * math.cos(end_rad)
            end_y = center_y + radius * math.sin(end_rad)
            
            # Move to start
            self.rapid_move(x=start_x, y=start_y)
            self.rapid_move(z=depth)
            
            # Calculate I and J (center offset)
            i = center_x - start_x
            j = center_y - start_y
            
            # Determine direction
            clockwise = (end_angle - start_angle) < 0
            
            # Cut arc
            self.arc_move(end_x, end_y, i, j, clockwise=clockwise)
            
            # Retract
            self.rapid_move(z=self.safety_height)
            self.add_line("")
            
    def cut_rectangle(self, x1: float, y1: float, x2: float, y2: float,
                    depth: float = 0.0):
        """Cut a rectangle"""
        points = [
            (x1, y1),
            (x2, y1),
            (x2, y2),
            (x1, y2)
        ]
        self.cut_contour(points, closed=True, depth=depth)
        
    def cut_pocket(self, outer_contour: List[Tuple[float, float]],
                  inner_contours: List[List[Tuple[float, float]]] = None,
                  stepdown: float = 1.0, final_depth: float = 5.0):
        """Cut a pocket (outer contour minus inner contours)"""
        if inner_contours is None:
            inner_contours = []
            
        current_depth = 0.0
        
        while current_depth < final_depth:
            current_depth = min(current_depth + stepdown, final_depth)
            
            # Cut outer contour
            self.cut_contour(outer_contour, closed=True, depth=-current_depth)
            
            # Cut inner contours (holes)
            for inner in inner_contours:
                self.cut_contour(inner, closed=True, depth=-current_depth)
                
    def cut_3d_surface(self, points: List[Tuple[float, float, float]],
                     feed: Optional[float] = None):
        """Cut a 3D surface (for complex foam shapes)"""
        if not points:
            return
            
        # Move to start
        start_x, start_y, start_z = points[0]
        self.rapid_move(x=start_x, y=start_y)
        self.rapid_move(z=start_z + self.safety_height)
        self.rapid_move(z=start_z)
        
        # Cut along surface
        for x, y, z in points[1:]:
            self.linear_move(x=x, y=y, z=z, feed=feed)
            
        # Retract
        self.rapid_move(z=self.safety_height)
        self.add_line("")
        
    def generate_from_shapes(self, shapes: List[dict], depth: float = 0.0):
        """Generate G-code from shape dictionary (from CAD viewer)
        
        Connects shapes using entry/exit points if specified.
        """
        prev_exit_point = None
        
        for i, shape in enumerate(shapes):
            shape_type = shape.get("type")

            if shape_type == "line":
                x1, y1 = shape["x1"], shape["y1"]
                x2, y2 = shape["x2"], shape["y2"]
                self.rapid_move(x=x1, y=y1)
                self.rapid_move(z=depth)
                self.linear_move(x=x2, y=y2, z=depth)
                self.rapid_move(z=self.safety_height)

            elif shape_type == "circle":
                cx, cy = shape["cx"], shape["cy"]
                radius = shape["radius"]
                self.cut_circle(cx, cy, radius, depth=depth)

            elif shape_type == "rectangle":
                x1, y1 = shape["x1"], shape["y1"]
                x2, y2 = shape["x2"], shape["y2"]
                self.cut_rectangle(x1, y1, x2, y2, depth=depth)

            elif shape_type == "arc":
                cx, cy = shape["cx"], shape["cy"]
                radius = shape["radius"]
                start_angle = shape.get("start_angle", 0)
                end_angle = shape.get("end_angle", 180)
                self.cut_circle(cx, cy, radius, depth=depth,
                              start_angle=start_angle, end_angle=end_angle)

            elif shape_type == "polyline":
                # Handle polylines from DXF
                points_data = shape.get("points", [])
                points = []
                for pt in points_data:
                    if isinstance(pt, dict):
                        points.append((pt["x"], pt["y"]))
                    elif isinstance(pt, (tuple, list)):
                        points.append((pt[0], pt[1]))
                if points:
                    closed = shape.get("closed", True)
                    start_index = shape.get("start_index", None)
                    clockwise = shape.get("clockwise", None)
                    entry_index = shape.get("entry_index", None)
                    exit_index = shape.get("exit_index", None)
                    
                    # Get entry/exit points
                    entry_point = points[entry_index] if entry_index is not None and 0 <= entry_index < len(points) else None
                    exit_point = points[exit_index] if exit_index is not None and 0 <= exit_index < len(points) else None
                    
                    # Connect from previous shape's exit to this shape's entry
                    if i > 0 and prev_exit_point is not None and entry_point is not None:
                        # Move from previous exit to this entry (bridge)
                        self.add_line(f"; Bridge from shape {i} to shape {i+1}")
                        self.rapid_move(z=self.safety_height)
                        self.rapid_move(x=prev_exit_point[0], y=prev_exit_point[1])
                        self.rapid_move(z=depth)
                        self.linear_move(x=entry_point[0], y=entry_point[1], z=depth)
                        self.add_line("")
                    
                    self.cut_contour(points, closed=closed, depth=depth,
                                    start_index=start_index, clockwise=clockwise)
                    
                    # Store exit point for next shape
                    prev_exit_point = exit_point

        self.add_line("")
        
    def load_from_dxf(self, filename: str, depth: float = 0.0):
        """Load shapes from DXF file and generate G-code"""
        if not HAS_EZDXF:
            raise ImportError("ezdxf library required. Install with: pip install ezdxf")
            
        doc = ezdxf.readfile(filename)
        msp = doc.modelspace()
        
        # Extract entities
        entities = []
        for entity in msp:
            if entity.dxftype() == "LINE":
                entities.append({
                    "type": "line",
                    "x1": entity.dxf.start.x,
                    "y1": entity.dxf.start.y,
                    "x2": entity.dxf.end.x,
                    "y2": entity.dxf.end.y
                })
            elif entity.dxftype() == "CIRCLE":
                entities.append({
                    "type": "circle",
                    "cx": entity.dxf.center.x,
                    "cy": entity.dxf.center.y,
                    "radius": entity.dxf.radius
                })
            elif entity.dxftype() == "ARC":
                center = entity.dxf.center
                radius = entity.dxf.radius
                start_angle = math.degrees(entity.dxf.start_angle)
                end_angle = math.degrees(entity.dxf.end_angle)
                entities.append({
                    "type": "arc",
                    "cx": center.x,
                    "cy": center.y,
                    "radius": radius,
                    "start_angle": start_angle,
                    "end_angle": end_angle
                })
            elif entity.dxftype() == "LWPOLYLINE":
                # Convert polyline to points
                points = []
                for point in entity.get_points():
                    points.append((point[0], point[1]))
                if len(points) > 1:
                    entities.append({
                        "type": "polyline",
                        "points": points
                    })
                    
        # Generate G-code from entities
        self.generate_from_shapes(entities, depth=depth)
        
    def save(self, filename: str):
        """Save G-code to file"""
        with open(filename, "w") as f:
            f.write("\n".join(self.lines))
            
    def get_gcode(self) -> str:
        """Get G-code as string"""
        return "\n".join(self.lines)
        
    def add_comment(self, comment: str):
        """Add a comment line"""
        self.add_line(f"; {comment}")
        
    def add_dwell(self, seconds: float):
        """Add a dwell/pause"""
        self.add_line(f"G4 P{seconds:.3f} ; Dwell for {seconds} seconds")
        
    def set_wire_on(self):
        """Turn wire on (if machine supports M-codes)"""
        self.add_line("M3 ; Turn wire on (adjust M-code for your machine)")
        
    def set_wire_off(self):
        """Turn wire off"""
        self.add_line("M5 ; Turn wire off")


def example_simple_cut():
    """Example: Simple rectangle cut"""
    gen = GCodeGenerator()
    gen.set_feed_rate(150.0)  # mm/min
    gen.set_safety_height(5.0)
    
    gen.header("Simple Rectangle Cut")
    gen.cut_rectangle(0, 0, 100, 50, depth=0.0)
    gen.footer()
    
    return gen.get_gcode()


def example_circle_cut():
    """Example: Circle cut"""
    gen = GCodeGenerator()
    gen.set_feed_rate(120.0)
    gen.set_safety_height(5.0)
    
    gen.header("Circle Cut")
    gen.cut_circle(50, 50, 25, depth=0.0)
    gen.footer()
    
    return gen.get_gcode()


def example_complex_shape():
    """Example: Complex shape with multiple cuts"""
    gen = GCodeGenerator()
    gen.set_feed_rate(100.0)
    gen.set_safety_height(10.0)
    
    gen.header("Complex Foam Cutting Pattern")
    
    # Outer rectangle
    gen.cut_rectangle(0, 0, 200, 100, depth=0.0)
    
    # Inner circle
    gen.cut_circle(100, 50, 30, depth=0.0)
    
    # Additional shapes
    points = [(10, 10), (50, 10), (50, 40), (10, 40)]
    gen.cut_contour(points, closed=True, depth=0.0)
    
    gen.footer()
    
    return gen.get_gcode()


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        # Command line usage
        if sys.argv[1] == "example":
            gcode = example_simple_cut()
            print(gcode)
        elif sys.argv[1] == "circle":
            gcode = example_circle_cut()
            print(gcode)
        elif sys.argv[1] == "complex":
            gcode = example_complex_shape()
            print(gcode)
        else:
            print("Usage: python3 gcode_generator.py [example|circle|complex]")
    else:
        # Interactive mode
        print("G-code Generator for Foam Cutting")
        print("=" * 40)
        print("\nExample usage:")
        print("  python3 gcode_generator.py example  # Simple rectangle")
        print("  python3 gcode_generator.py circle   # Circle cut")
        print("  python3 gcode_generator.py complex  # Complex pattern")
        print("\nOr use as a library:")
        print("  from gcode_generator import GCodeGenerator")
        print("  gen = GCodeGenerator()")
        print("  gen.header()")
        print("  gen.cut_rectangle(0, 0, 100, 50)")
        print("  gen.footer()")
        print("  gen.save('output.nc')")

